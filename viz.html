<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Pretty Printer Tree Visualization</title>
  <script src="https://unpkg.com/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    #graph {
      width: 100%;
      height: calc(100vh - 40px);
      border: 1px solid #444;
      background: #252525;
    }
  </style>
</head>
<body>
  <svg id="graph"></svg>

  <script>
    async function loadAndRender() {
      // Load the JSON
      const response = await fetch('tree.json');
      const data = await response.json();

      // Convert to ELK format - flatten but track depth and order
      // Tiny nodes are NOT shared (inline immediates), pool nodes ARE shared (deduplicated)
      const nodes = new Map();
      const edges = [];
      let orderCounter = 0;
      let tinyNodeCounter = 0;

      function collectNodes(node, depth = 0, isLeft = true, parentId = null) {
        const isTiny = node.textKind === 'tiny';
        const isPool = node.textKind === 'pool';
        const isOper = node.kind === 'plus' || node.kind === 'fork';

        // Only tiny text nodes are inline (not shared)
        // Pool strings and operators are deduplicated
        const nodeId = isTiny ? `${node.id}_${tinyNodeCounter++}` : node.id;

        if (!nodes.has(nodeId)) {
          const elkNode = {
            id: nodeId,
            width: Math.max(60, node.label.length * 10 + 20),
            height: 40,
            labels: [{ text: node.label }],
            kind: node.kind,
            textKind: node.textKind,
            layoutOptions: {
              'elk.priority': String(1000 - depth * 10),
              'elk.layered.priority.direction': String(orderCounter++)
            }
          };
          nodes.set(nodeId, elkNode);
        }

        if (node.children) {
          node.children.forEach((child, idx) => {
            const childId = collectNodes(child, depth + 1, idx === 0, nodeId);
            edges.push({
              id: `e_${nodeId}_${childId}_${idx}`,
              sources: [nodeId],
              targets: [childId],
              layoutOptions: {
                'elk.priority': String(idx === 0 ? 100 : 50)
              }
            });
          });
        }

        return nodeId;
      }

      collectNodes(data);

      const graph = {
        id: 'root',
        children: Array.from(nodes.values()),
        edges: edges
      };

      // Layout with ELK
      const elk = new ELK();
      const layout = await elk.layout(graph, {
        layoutOptions: {
          'elk.algorithm': 'layered',
          'elk.direction': 'DOWN',
          'elk.spacing.nodeNode': '40',
          'elk.layered.spacing.nodeNodeBetweenLayers': '60',
          'elk.layered.nodePlacement.strategy': 'NETWORK_SIMPLEX',
          'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
          'elk.partitioning.activate': 'true'
        }
      });

      // Render SVG
      const svg = document.getElementById('graph');
      const xmlns = "http://www.w3.org/2000/svg";

      // Add arrowhead marker
      const defs = document.createElementNS(xmlns, 'defs');
      const marker = document.createElementNS(xmlns, 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      const polygon = document.createElementNS(xmlns, 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#888');
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);

      // Render nodes
      layout.children.forEach(node => {
        const label = node.labels[0].text;
        const kind = node.kind || 'text';
        const textKind = node.textKind;
        const isPlus = label === '+' || label.startsWith('+');
        const isFork = label === '?' || label.startsWith('?');
        const isPool = textKind === 'pool';
        const isTiny = textKind === 'tiny';

        // Escape whitespace for display
        let displayLabel = label;
        if (label === ' ') displayLabel = '␣';
        else if (label === '\n') displayLabel = '␤';
        else if (label === '\t') displayLabel = '⇥';

        // Draw rectangle or dot
        if (isPlus) {
          // Draw small dot for plus nodes
          const circle = document.createElementNS(xmlns, 'circle');
          circle.setAttribute('cx', node.x + node.width / 2);
          circle.setAttribute('cy', node.y + node.height / 2);
          circle.setAttribute('r', '6');
          circle.setAttribute('fill', '#666');
          svg.appendChild(circle);
        } else {
          const rect = document.createElementNS(xmlns, 'rect');
          rect.setAttribute('x', node.x);
          rect.setAttribute('y', node.y);
          rect.setAttribute('width', node.width);
          rect.setAttribute('height', node.height);

          // Color based on type
          let fill, shape;
          if (isFork) {
            fill = '#d7ba7d';
            shape = 'box';
          } else if (isPool) {
            fill = '#4ec9b0';
            shape = 'ellipse';
          } else {
            fill = '#569cd6';
            shape = 'box';
          }

          rect.setAttribute('fill', fill);
          rect.setAttribute('stroke', '#888');
          rect.setAttribute('stroke-width', isPool ? '2' : '1');
          rect.setAttribute('rx', isPool ? node.height / 2 : '4');
          svg.appendChild(rect);

          // Draw label
          const text = document.createElementNS(xmlns, 'text');
          text.setAttribute('x', node.x + node.width / 2);
          text.setAttribute('y', node.y + node.height / 2 + 5);
          text.setAttribute('fill', '#1e1e1e');
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('font-size', '12');
          text.setAttribute('font-weight', isPool ? 'bold' : 'normal');
          text.setAttribute('font-family', 'Monaco, Menlo, monospace');
          text.textContent = displayLabel;
          svg.appendChild(text);
        }
      });

      // Draw edges
      layout.edges.forEach(edge => {
        if (!edge.sections) return;
        edge.sections.forEach(section => {
          const path = document.createElementNS(xmlns, 'path');
          let d = `M ${section.startPoint.x} ${section.startPoint.y}`;
          if (section.bendPoints) {
            section.bendPoints.forEach(bp => {
              d += ` L ${bp.x} ${bp.y}`;
            });
          }
          d += ` L ${section.endPoint.x} ${section.endPoint.y}`;
          path.setAttribute('d', d);
          path.setAttribute('stroke', edge.id.includes('_a') ? '#569cd6' : '#f48771');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('fill', 'none');
          path.setAttribute('marker-end', 'url(#arrowhead)');
          svg.appendChild(path);
        });
      });

      // Set SVG viewBox
      svg.setAttribute('viewBox', `0 0 ${layout.width || 1000} ${layout.height || 1000}`);
    }

    loadAndRender().catch(console.error);
  </script>
</body>
</html>
